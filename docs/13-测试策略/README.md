# 13. 测试策略与执行

本章定义了项目的整体测试策略，并提供了覆盖各个层面的详细测试用例，以确保应用的质量、稳定性和性能。

## 1. 测试策略概述

项目采用分层测试策略，确保在软件生命周期的不同阶段都能及时发现并修复问题。
- **单元测试**: 保证代码模块的正确性。
- **集成测试**: 验证服务间的交互与协作。
- **接口自动化测试**: 确保API功能的稳定与回归。
- **性能与压力测试**: 评估系统容量和瓶颈。
- **混沌工程**: 检验系统的弹性和容错能力。

## 2. 详细测试用例

### 2.1 单元测试 (Unit Testing)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **通用工具类** | `com.nh.common.utils.DateUtils` | 测试日期格式化功能 | 无 | 1. 定义一个`Date`对象。<br>2. 调用`DateUtils.format(date)`方法。<br>3. 检查返回的字符串是否为`yyyy-MM-dd HH:mm:ss`格式。 | 返回格式正确的日期字符串。 | 待执行 | 待执行 |
| **通用工具类** | `com.nh.common.utils.ValidatorUtils` | 测试手机号验证功能（有效输入） | 无 | 1. 输入一个合法的手机号码（如`13800138000`）。<br>2. 调用`ValidatorUtils.isMobile(phone)`。 | 返回`true`。 | 待执行 | 待执行 |
| **通用工具类** | `com.nh.common.utils.ValidatorUtils` | 测试手机号验证功能（无效输入） | 无 | 1. 输入一个非法的手机号码（如`123456`）。<br>2. 调用`ValidatorUtils.isMobile(phone)`。 | 返回`false`。 | 待执行 | 待执行 |
| **用户服务** | `UserService`业务逻辑 | 测试用户注册（已存在用户名） | 数据库中已存在用户`testuser` | 1. 创建一个用户对象，用户名为`testuser`。<br>2. 调用`userService.register(user)`。<br>3. 捕获并断言抛出的异常类型。 | 抛出`UsernameExistsException`。 | 待执行 | 待执行 |
| **订单服务** | `OrderService`价格计算 | 测试订单总价计算（含优惠券） | Mock一个`ProductService`和`CouponService` | 1. 创建一个包含多个商品的订单项列表。<br>2. 创建一个满100减10的优惠券。<br>3. 调用`orderService.calculateTotalPrice(items, coupon)`。 | 返回正确的折后价格。 | 待执行 | 待执行 |

### 2.2 集成测试 (Integration Testing)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **用户-订单服务** | 用户获取订单列表 | 测试用户服务通过Feign调用订单服务 | 启动`user-service`和`order-service`；用户`1001`在数据库中有3条订单记录 | 1. 模拟用户`1001`登录，获取Token。<br>2. 携带Token请求`user-service`的`/api/user/orders`接口。 | 1. `user-service`成功调用`order-service`。<br>2. 返回状态码200，响应体中包含3条该用户的订单信息。 | 待执行 | 待执行 |
| **商品-库存服务** | 下单扣减库存 | 测试订单服务调用库存服务扣减库存 | 启动`order-service`和`stock-service`；商品`P001`库存为10 | 1. 调用`order-service`创建订单，购买2件商品`P001`。<br>2. `order-service`内部调用`stock-service`的扣减库存接口。 | 1. 订单创建成功。<br>2. 数据库中商品`P001`的库存变为8。 | 待执行 | 待执行 |
| **分布式事务** | Seata-AT跨服务事务 | 测试下单成功（订单、库存、账户服务联动） | 启动`order-service`, `stock-service`, `account-service`, Seata Server；商品库存充足，用户余额充足。 | 1. 发起下单请求。<br>2. 订单服务：创建订单->调用库存服务->调用账户服务。<br>3. 所有服务执行成功。 | 1. 订单状态为"已支付"。<br>2. 商品库存扣减。<br>3. 用户余额扣减。<br>4. 所有服务的`undo_log`被清理。 | 待执行 | 待执行 |
| **分布式事务** | Seata-AT事务回滚 | 测试下单失败（账户余额不足） | 同上，但用户余额不足。 | 1. 发起下单请求。<br>2. 订单服务创建订单，库存服务扣减库存。<br>3. 账户服务因余额不足，抛出异常。 | 1. 订单状态为"已关闭"或"创建失败"。<br>2. 商品库存回滚到原始值。<br>3. 用户余额不变。 | 待执行 | 待执行 |

### 2.3 接口自动化测试 (API Automation Testing)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **用户服务API** | `/api/auth/login` | 用户正常登录 | 测试用户`test:123456`已注册 | 1. 使用`username=test`和`password=123456`请求登录接口。<br>2. 提取响应中的`token`。 | 1. 响应状态码为200。<br>2. 响应体中包含非空的`token`字段。 | 待执行 | 待执行 |
| **用户服务API** | `/api/auth/login` | 用户密码错误登录 | 测试用户`test:123456`已注册 | 1. 使用`username=test`和`password=wrongpass`请求登录接口。 | 响应状态码为401或业务码表示"用户名或密码错误"。 | 待执行 | 待执行 |
| **商品服务API** | `/api/items/{id}` | 获取存在的商品详情 | 数据库中存在ID为`1`的商品 | 1. 请求`/api/items/1`。 | 1. 响应状态码为200。<br>2. 响应体中包含ID为`1`的商品完整信息。 | 待执行 | 待执行 |
| **商品服务API** | `/api/items/{id}` | 获取不存在的商品详情 | 数据库中不存在ID为`9999`的商品 | 1. 请求`/api/items/9999`。 | 响应状态码为404。 | 待执行 | 待执行 |
| **API网关** | 认证过滤器 | 无有效Token访问受保护资源 | `/api/user/profile`接口需要认证 | 1. 不携带`Authorization`头，请求`/api/user/profile`。 | API网关返回401 Unauthorized错误。 | 待执行 | 待执行 |
| **API网关** | 限流过滤器 | 短时高频访问接口 | 用户查询接口配置了每秒5次的限流规则 | 1. 在1秒内连续请求6次用户查询接口。 | 前5次请求成功（200 OK），第6次请求被拒绝（429 Too Many Requests）。 | 待执行 | 待执行 |

### 2.4 性能与压力测试 (Performance & Stress Testing)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **核心接口** | 商品详情页 | 基准性能测试（100并发） | 部署测试环境，准备好商品数据 | 1. 使用JMeter或Gatling模拟100个虚拟用户并发访问商品详情页接口。<br>2. 持续运行10分钟。 | 1. 平均响应时间 < 200ms。<br>2. P95响应时间 < 500ms。<br>3. 错误率 < 0.1%。 | 待执行 | 待执行 |
| **核心接口** | 商品详情页 | 压力测试 | 同上 | 1. 从100并发开始，每分钟增加50个虚拟用户，直到系统出现显著性能拐点（错误率>1%或响应时间急剧增加）。 | 确定系统处理商品详情查询的最大QPS和最佳并发数。 | 待执行 | 待执行 |
| **核心流程** | 下单流程 | 混合场景压力测试 | 部署完整测试环境，准备用户、商品、库存数据 | 1. 模拟混合场景：80%读（浏览商品），20%写（下单）。<br>2. 模拟500并发用户，持续30分钟。 | 1. 系统保持稳定，无服务宕机。<br>2. 下单成功率 > 99%。<br>3. 数据库、CPU、内存等资源使用率在安全范围内。 | 待执行 | 待执行 |

### 2.5 混沌工程与故障注入测试 (Chaos Engineering)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **服务容错** | 订单服务实例宕机 | 测试订单服务部分不可用时，网关的熔断机制 | 部署完整环境，有3个订单服务实例。 | 1. 正常访问下单接口。<br>2. 使用`kubectl`或`docker kill`随机杀死一个订单服务Pod。<br>3. 持续发起下单请求。 | 1. 系统在短时间内可能会有少量请求失败。<br>2. 网关（Sentinel）应能自动熔断对故障实例的请求，将流量转发到健康实例。<br>3. 整体下单成功率应保持在可接受水平。 | 待执行 | 待执行 |
| **服务容错** | 数据库连接池耗尽 | 测试数据库连接失败时，服务的降级表现 | 启动商品服务，人为将数据库最大连接数设为一个极小值（如1） | 1. 模拟多个并发请求访问需要查库的商品服务接口。<br>2. 观察服务日志和返回结果。 | 1. 服务不应崩溃，应能捕获数据库连接异常。<br>2. 返回统一的、对用户友好的错误提示或降级数据（如缓存）。<br>3. CPU不会因此飙升。 | 待执行 | 待执行 |
| **基础设施** | Redis节点故障 | 测试缓存服务不可用时系统的表现 | 部署完整环境，业务强依赖Redis缓存 | 1. 使用防火墙或工具模拟Redis主节点网络分区或宕机。<br>2. 访问依赖缓存的页面（如首页、商品详情页）。 | 1. 页面加载可能变慢，但系统不应崩溃。<br>2. 业务应能绕过缓存，直接查询数据库（缓存旁路模式），保证核心功能可用。<br>3. Redis恢复后，缓存应能被重新预热。 | 待执行 | 待执行 |

### 2.6 业务流程测试 (Business Process Testing)

#### A. 用户管理 (User Management)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **用户注册** | 正常注册 | 使用有效的、未被注册的手机号和用户名进行注册 | 无 | 1. 访问注册页面。<br>2. 输入未注册的手机号、用户名、密码。<br>3. 点击注册按钮。 | 1. 提示"注册成功"。<br>2. 页面跳转到登录页。<br>3. 数据库`user`表中新增一条记录。 | 待执行 | 待执行 |
| **用户注册** | 用户名已存在 | 使用已存在的用户名进行注册 | 用户`existing_user`已存在 | 1. 访问注册页面。<br>2. 输入`existing_user`及其他信息。<br>3. 点击注册。 | 提示"用户名已存在"，注册失败。 | 待执行 | 待执行 |
| **用户登录** | 正常登录 | 使用已注册的有效凭证登录 | 用户`testuser/123456`已注册并处于正常状态 | 1. 访问登录页面。<br>2. 输入`testuser`和`123456`。<br>3. 点击登录。 | 1. 登录成功，跳转到系统主页。<br>2. 后端返回有效的JWT。 | 待执行 | 待执行 |
| **用户登录** | 密码错误 | 使用错误的密码登录 | 用户`testuser/123456`已注册 | 1. 访问登录页面。<br>2. 输入`testuser`和`wrong_password`。<br>3. 点击登录。 | 提示"用户名或密码错误"，登录失败。 | 待执行 | 待执行 |
| **用户登录** | 账户被锁定 | 使用被锁定的账户登录 | 用户`locked_user`的账户状态为"锁定" | 1. 访问登录页面。<br>2. 输入`locked_user`的正确凭证。<br>3. 点击登录。 | 提示"账户已被锁定"，登录失败。 | 待执行 | 待执行 |
| **用户信息** | 获取个人信息 | 已登录用户查看自己的个人资料 | 用户已登录 | 1. 访问"个人中心"页面。 | 页面正确显示当前用户的昵称、头像、手机号等信息。 | 待执行 | 待执行 |
| **用户信息** | 修改个人信息 | 用户修改自己的昵称和头像 | 用户已登录 | 1. 访问"个人中心"的编辑页面。<br>2. 修改昵称为`new_nickname`并上传新头像。<br>3. 点击保存。 | 1. 提示"修改成功"。<br>2. 页面显示新的昵称和头像。<br>3. 数据库中对应记录被更新。 | 待执行 | 待执行 |

#### B. 商品管理 (Product Management)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **商品浏览** | 查看商品列表 | 用户匿名访问商品列表页 | 系统中有已上架的商品 | 1. 访问商品列表页。<br>2. 查看分页功能。 | 1. 页面成功展示商品列表，包含图片、名称、价格。<br>2. 分页、排序、筛选功能正常。 | 待执行 | 待执行 |
| **商品浏览** | 查看商品详情 | 用户匿名访问单个商品详情页 | 商品`P001`已上架 | 1. 从列表页点击商品`P001`。<br>2. 直接访问商品`P001`的URL。 | 页面成功展示该商品的详细信息，包括规格、描述、库存状态、用户评价。 | 待执行 | 待执行 |
| **商品搜索** | 关键字搜索 | 用户使用关键字进行搜索 | 有商品名称包含"笔记本电脑" | 1. 在搜索框输入"笔记本电脑"。<br>2. 点击搜索。 | 返回所有名称或描述中包含"笔记本电脑"的商品列表。 | 待执行 | 待执行 |
| **商品搜索** | 分类筛选搜索 | 用户在搜索结果上按分类进行筛选 | 搜索结果中包含"电子产品"和"图书"两类商品 | 1. 搜索商品。<br>2. 在筛选区域点击"电子产品"分类。 | 搜索结果列表只展示"电子产品"分类下的商品。 | 待执行 | 待执行 |
| **后台管理** | 添加商品 | 管理员在后台添加一个新商品 | 管理员已登录 | 1. 访问后台商品管理模块。<br>2. 点击"添加商品"按钮。<br>3. 填写所有必填信息（名称、价格、库存、分类、图片等）。<br>4. 点击"提交"。 | 1. 提示"添加成功"。<br>2. 商品列表页出现新添加的商品。<br>3. 数据库中新增商品记录。 | 待执行 | 待执行 |
| **后台管理** | 修改商品 | 管理员在后台修改一个商品的信息 | 管理员已登录，商品`P002`存在 | 1. 在后台商品列表中找到`P002`并点击"编辑"。<br>2. 将其价格修改为`999`。<br>3. 点击"保存"。 | 1. 提示"修改成功"。<br>2. 数据库中商品`P002`的价格被更新为`999`。<br>3. 前台详情页显示新价格。 | 待执行 | 待执行 |
| **后台管理** | 下架商品 | 管理员在后台下架一个商品 | 管理员已登录，商品`P003`处于"已上架"状态 | 1. 在后台商品列表中找到`P003`并点击"下架"。<br>2. 在确认框中点击"确认"。 | 1. 提示"下架成功"。<br>2. 商品`P003`状态变为"已下架"。<br>3. 前台商品列表和搜索结果中不再出现该商品。 | 待执行 | 待执行 |

#### D. 库存管理 (Inventory Management)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **库存联动** | 下单扣减库存 | 用户成功下单后，对应商品库存减少 | 商品`P005`库存为100 | 1. 用户购买5件商品`P005`并完成支付。 | 数据库中商品`P005`的库存数量变为95。 | 待执行 | 待执行 |
| **库存联动** | 取消订单释放库存 | 用户取消"待支付"订单后，库存被释放 | 商品`P006`库存为50，一个待支付订单锁定了3件库存 | 1. 用户取消该订单。 | 数据库中商品`P006`的可用库存恢复为50。 | 待执行 | 待执行 |
| **后台管理** | 手动入库 | 管理员为某商品增加库存 | 商品`P007`库存为20 | 1. 后台找到商品`P007`的库存管理。<br>2. 执行"入库"操作，数量为30。<br>3. 提交。 | 数据库中商品`P007`的库存变为50。 | 待执行 | 待执行 |

#### E. 评价系统 (Review System)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **发表评价** | 用户发表图文评价 | 用户对已完成的订单商品发表评价 | 用户已登录，订单`O005`已完成，且未发表过评价 | 1. 进入"我的订单"，找到`O005`。<br>2. 点击"评价"。<br>3. 输入文字评价，上传图片，给出评分。<br>4. 提交。 | 1. 提示"评价成功"。<br>2. 对应商品详情页的评价列表中出现该条新评价。 | 待执行 | 待执行 |
| **发表评价** | 重复评价 | 用户尝试对已评价过的订单商品再次评价 | 订单`O005`已被当前用户评价过 | 1. 再次进入订单`O005`。<br>2. 查找"评价"按钮。 | "评价"按钮应消失或变为"已评价/查看评价"。 | 待执行 | 待执行 |
| **查看评价** | 商品详情页查看评价 | 任何用户在商品详情页查看评价列表 | 商品`P008`有多条不同用户的评价 | 1. 访问商品`P008`的详情页。<br>2. 滚动到评价区域。 | 评价列表按时间倒序展示，包含用户昵称（可脱敏）、评分、内容和图片。 | 待执行 | 待执行 |

#### F. 通知系统 (Notification System)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **通知触发** | 支付成功通知 | 用户支付成功后收到通知 | - | 1. 用户成功支付一笔订单。 | 用户能通过站内信或短信收到支付成功的通知。 | 待执行 | 待执行 |
| **通知触发** | 发货通知 | 商家后台发货后收到通知 | - | 1. 商家在后台对一笔订单执行发货操作。 | 用户能收到包含物流信息的发货通知。 | 待执行 | 待执行 |
| **通知查看** | 查看通知列表 | 用户查看自己的站内信列表 | 用户已登录，并收到过多条不同类型的通知 | 1. 访问"消息中心"。 | 消息列表清晰地展示所有通知，区分已读和未读状态。 | 待执行 | 待执行 |

#### G. 安全与认证 (Security & Authentication)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **权限控制** | 管理员访问管理接口 | 拥有`ADMIN`角色的用户访问后台管理接口 | 1. 用户`admin`拥有`ADMIN`角色并已登录。<br>2. `/api/admin/products`接口要求`ADMIN`角色。 | 1. 使用`admin`用户的Token请求`/api/admin/products`。 | 请求成功，返回状态码200。 | 待执行 | 待执行 |
| **权限控制** | 普通用户访问管理接口 | 只有`USER`角色的用户尝试访问后台管理接口 | 1. 用户`normal_user`只有`USER`角色并已登录。<br>2. `/api/admin/products`接口要求`ADMIN`角色。 | 1. 使用`normal_user`的Token请求`/api/admin/products`。 | 请求被拒绝，返回状态码403 Forbidden。 | 待执行 | 待执行 |
| **权限控制** | 越权访问数据 | 用户A尝试访问用户B的数据 | 1. 用户A和用户B都已登录。<br>2. `/api/orders/{userId}`接口设计为只能访问自己的订单。 | 1. 使用用户A的Token请求`/api/orders/{userId_B}`。 | 请求被拒绝，返回403或提示"无权访问"。 | 待执行 | 待执行 |
| **安全策略** | JWT过期 | 使用一个已过期的JWT访问受保护接口 | 1. 用户登录获取一个JWT。<br>2. 等待JWT过期（或手动修改其过期时间）。 | 1. 携带过期的JWT请求任意受保护接口。 | 请求被拒绝，返回状态码401 Unauthorized，并提示Token已过期。 | 待执行 | 待执行 |

#### H. 缓存策略 (Cache Strategy)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **缓存有效性** | 命中缓存 | 验证热点数据是否从缓存中读取 | 1. 商品`P001`为热点商品，已提前预热到Redis缓存中。<br>2. 数据库中该商品价格为100元。 | 1. 请求商品`P001`的详情接口。<br>2. 后台修改数据库中`P001`的价格为200元（不更新缓存）。<br>3. 再次请求商品`P001`的详情接口。 | 1. 第一次请求响应迅速。<br>2. 第二次请求返回的价格依然是100元，证明读取的是缓存而非数据库。 | 待执行 | 待执行 |
| **缓存穿透** | 防缓存穿透（空对象缓存） | 请求一个数据库中根本不存在的数据 | 系统已实现对不存在的key缓存空对象的策略。 | 1. 请求一个不存在的商品ID，如`non_exist_id`。<br>2. 在短时间内多次重复请求该ID。 | 1. 第一次请求会查询数据库，然后缓存一个空结果。<br>2. 后续的请求应直接命中空缓存，不会再查询数据库。 | 待执行 | 待执行 |
| **缓存击穿** | 防缓存击穿（分布式锁） | 高并发访问一个刚失效的热点数据 | 1. 商品`P002`是热点数据，其缓存即将过期。<br>2. 系统已实现使用分布式锁来重建缓存。 | 1. 模拟大量并发请求同时访问商品`P002`的接口，恰好在其缓存失效的瞬间。 | 1. 只有一个请求能获取到分布式锁，去查询数据库并重建缓存。<br>2. 其他请求会等待或返回稍旧的数据，但不会将大量请求直接打到数据库上。 | 待执行 | 待执行 |
| **数据一致性** | 缓存更新策略（Cache-Aside） | 修改数据后，缓存被正确处理 | 系统采用Cache-Aside（先更新数据库，再删除缓存）策略。 | 1. 请求商品`P003`详情，使其加载到缓存。<br>2. 通过后台管理接口修改`P003`的价格。<br>3. 再次请求商品`P003`详情。 | 1. 管理接口成功更新数据库，并删除了Redis中`P003`的缓存。<br>2. 第二次请求因缓存未命中，会查询数据库，获取到最新价格，并重新写入缓存。 | 待执行 | 待执行 |

#### I. 特殊业务场景 (Special Scenarios)

| 模块 | 功能点 | 测试用例描述 | 前置条件 | 测试步骤 | 预期结果 | 实际结果 | 测试状态 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **秒杀场景** | 库存预热与限流 | 秒杀开始前，库存加载到缓存，并对用户进行限流 | 1. 秒杀商品`S001`总库存10件，已预热到Redis。<br>2. 秒杀链接设置了令牌桶算法，QPS限制为1000。 | 1. 秒杀开始前，大量用户刷新页面。<br>2. 秒杀开始，模拟2000 QPS的请求访问秒杀接口。 | 1. 秒杀开始前，页面能正常展示。<br>2. 秒杀开始后，约1000个请求能成功进入后端逻辑，其余请求被限流，直接返回"活动火爆，请稍后再试"。 | 待执行 | 待执行 |
| **秒杀场景** | Redis原子减库存 | 后端通过Redis原子操作扣减库存，防止超卖 | 1. 秒杀商品`S001`在Redis中的库存为10。<br>2. 通过Lua脚本或INCR/DECR保证原子性。 | 1. 模拟100个已通过限流的并发请求执行扣减库存操作。 | 1. Redis中的库存值最终变为0。<br>2. 只有10个请求能成功扣减库存并进入下一步（生成订单），其余90个请求失败，返回"已售罄"。 | 待执行 | 待执行 |
| **秒杀场景** | 订单异步处理 | 库存扣减成功后，将订单信息推入消息队列进行异步处理 | 系统已集成RabbitMQ或Kafka。 | 1. 成功扣减Redis库存后，构造订单消息。<br>2. 将消息发送到订单处理队列。 | 1. 扣减库存接口能迅速返回成功响应给用户。<br>2. 消息队列中能接收到10条订单创建消息。<br>3. 订单服务消费者能正确从队列拉取消息并创建订单。 | 待执行 | 待执行 |
| **秒杀场景** | 用户购买限制 | 同一用户只能成功秒杀一件商品 | 秒杀活动设置了单用户限购1件。 | 1. 用户A成功秒杀一件商品后，再次发起秒杀请求。 | 1. 第一次请求成功。<br>2. 第二次请求在业务逻辑层面被拦截，返回"您已参与过此活动"。 | 待执行 | 待执行 |

## 13.1 概述

本章节将阐述电商平台项目为保障软件质量而制定的多层次、全方位的测试策略。全面的测试是确保系统功能正确、性能达标、安全可靠以及用户体验良好的关键。我们将介绍从单元测试到端到端测试的自动化测试金字塔，以及性能测试和混沌工程等专项测试。

## 13.2 自动化测试金字塔

项目遵循经典的"测试金字塔"模型，将测试资源主要投入到底层的单元测试，向上逐层减少。

```mermaid
graph TD
    subgraph "自动化测试金字塔"
        direction BT
        A["E2E Tests (Cypress)"]
        B["Service/Integration Tests (Spring Boot Test)"]
        C["Unit Tests (JUnit/Mockito, Vitest)"]
        
        C -- 高 -- B
        B -- 中 -- A
        
        subgraph "UI层面"
            A
        end
        subgraph "服务间/API层面"
            B
        end
        subgraph "代码/方法层面"
            C
        end
    end

    style C fill:#9f9,stroke:#333,stroke-width:2px
    style B fill:#9cf,stroke:#333,stroke-width:2px
    style A fill:#f99,stroke:#333,stroke-width:2px

    note right of C
      <b>数量多，速度快，成本低</b>
      - 覆盖核心业务逻辑
      - 快速反馈
    end
    note right of B
      <b>数量中，速度中，成本中</b>
      - 验证服务间交互
      - 测试API契约
    end
    note right of A
      <b>数量少，速度慢，成本高</b>
      - 模拟真实用户操作
      - 覆盖核心业务流程
    end
```

## 13.3 单元测试 (Unit Testing)

-   **目标**: 验证代码中最小的可测试单元（方法、类）的行为是否符合预期。
-   **后端**:
    -   **工具**: `JUnit 5`, `Mockito`
    -   **范围**: 主要覆盖Service层和Util类的公共方法。对于复杂的业务逻辑，要求高覆盖率。
    -   **实践**: 使用Mockito来Mock掉外部依赖（如Mapper、FeignClient、RedisTemplate），使得测试可以独立、快速地运行。
    -   **示例 (`UserServiceTest.java`)**:
        ```java
        @ExtendWith(MockitoExtension.class)
        class UserServiceTest {
            @Mock
            private UserMapper userMapper;
            @Mock
            private PasswordEncoder passwordEncoder;
            
            @InjectMocks
            private UserServiceImpl userService;

            @Test
            void testRegister_Success() {
                // Given
                User user = new User("test", "password");
                when(userMapper.findByUsername("test")).thenReturn(null);
                when(passwordEncoder.encode("password")).thenReturn("encoded_password");

                // When
                userService.register(user);

                // Then
                verify(userMapper).insert(any(User.class));
            }
        }
        ```
-   **前端**:
    -   **工具**: `Vitest`, `@vue/test-utils`
    -   **范围**: 主要覆盖公共组件（Components）和工具函数（Utils）的逻辑。
    -   **实践**: 使用`@vue/test-utils`来挂载组件，测试其props、events以及内部状态的变化是否正确。

## 13.4 集成测试 (Integration Testing)

-   **目标**: 验证服务内部不同模块之间，以及服务与外部依赖（如数据库、Redis）之间的交互是否正确。
-   **后端**:
    -   **工具**: `Spring Boot Test`, `Testcontainers`
    -   **范围**: 测试从Controller到Service再到Mapper的完整调用链路。
    -   **实践**:
        -   使用`@SpringBootTest`注解来启动一个完整的Spring应用上下文。
        -   使用`Testcontainers`在测试执行前，动态地启动一个真实的数据库或Redis的Docker容器。这保证了测试环境与生产环境的高度一致性，同时避免了对共享测试环境的依赖。
    -   **示例 (`ItemControllerTest.java`)**:
        ```java
        @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
        @Testcontainers
        class ItemControllerTest {
            @Container
            private static final MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0");

            @Autowired
            private TestRestTemplate restTemplate;
            
            @Test
            void testGetItemDetail_Success() {
                // ...准备数据...
                ResponseEntity<ItemDTO> response = restTemplate.getForEntity("/api/items/1", ItemDTO.class);
                assertEquals(HttpStatus.OK, response.getStatusCode());
                assertEquals("商品1", response.getBody().getName());
            }
        }
        ```

## 13.5 端到端测试 (End-to-End Testing)

-   **目标**: 从用户的视角，模拟真实的操作流程，验证整个系统（前端+后端）的功能是否正确。
-   **前端**:
    -   **工具**: `Cypress`
    -   **范围**: 覆盖最核心的用户旅程，如用户注册登录、浏览商品、加入购物车、下单支付等。
    -   **实践**: Cypress通过直接在浏览器中运行测试脚本，可以真实地模拟用户的点击、输入等行为，并断言UI的状态变化。测试脚本在CI/CD流程中自动执行。
    -   **示例 (`order_spec.cy.js`)**:
        ```javascript
        describe('Order Process', () => {
          it('allows a user to place an order', () => {
            cy.visit('/login');
            cy.get('input[name=username]').type('testuser');
            cy.get('input[name=password]').type('password');
            cy.get('button[type=submit]').click();

            cy.visit('/items/1');
            cy.contains('button', '加入购物车').click();
            cy.visit('/cart');
            cy.contains('button', '去结算').click();

            cy.get('input[name=address]').type('My Address');
            cy.contains('button', '提交订单').click();

            cy.contains('h1', '订单提交成功').should('be.visible');
          });
        });
        ```

## 13.6 性能测试

-   **目标**: 评估系统在不同负载下的性能表现，找出瓶颈，确保系统能够满足预期的性能指标（TPS、响应时间、并发用户数）。
-   **工具**: `JMeter`, `Gatling`
-   **流程**:
    1.  **场景设计**: 定义测试场景，如模拟1000个用户同时浏览商品和下单。
    2.  **脚本开发**: 使用JMeter或Gatling编写测试脚本。
    3.  **压力注入**: 从多台压力机发起请求，模拟高并发负载。
    4.  **性能监控**: 在测试过程中，密切监控应用、数据库、中间件和服务器的各项性能指标。
    5.  **结果分析**: 分析测试报告，定位性能瓶颈，并进行调优。

## 13.7 混沌工程 (Chaos Engineering)

-   **目标**: 通过主动向系统中注入故障，来检验系统的弹性和容错能力，发现潜在的弱点。
-   **工具**: `Chaos Mesh`, `LitmusChaos` (基于Kubernetes)
-   **实践**:
    -   **故障注入**: 在测试环境中，定期或随机地执行混沌实验，例如：
        -   **Pod故障**: 随机杀死某个服务的Pod，观察K8s是否能自动拉起新Pod，以及服务是否能自动恢复。
        -   **网络故障**: 模拟服务间的网络延迟或丢包，观察熔断和降级策略是否生效。
        -   **资源故障**: 模拟CPU或内存飙升，观察服务的表现和HPA是否触发。
    -   **验证与改进**: 观察系统在混沌实验中的表现，如果与预期不符，则说明系统的弹性设计存在问题，需要进行改进。

## 13.8 总结

项目通过建立一个分层的、自动化的测试体系，并结合专项的性能测试和混沌工程，力求在开发过程的早期就发现并修复问题，从而系统性地保障最终交付的软件质量。测试不仅是QA团队的责任，更是整个开发团队文化的一部分。 